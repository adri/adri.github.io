---
layout: post
title: Improving Caching of Nested Fragment for Traffic Spikes
summary: 
categories: cache, invalidation
image: 
published: false
---

Last week I learned about two caching techniques and how to combined them to get a more effective caching strategy.

First I wanted to solve the **"dogpile" effect** which can happen during a traffic spike, then I learned about the **"Russian doll" approach** for caching nested template blocks. Finally, combining the two 

## Russian Doll Cache
For caching nested template partials the **"Russian doll" approach** works well with timestamp-based cache keys. How this works is nicely explained in the article [How key-based cache expiration works](https://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works). Using last updated timestamps for cache keys of the partials allows for individual cache updates and minimal re-rendering. The cache value only needs to be regenerated when the timestamp changes.

This great unless the cache key changes during a traffic spike. The high load can lead to the "dog-pile" effect.

## Dog Pile Effect
The **"dog-pile" effect**, also [cache stampede](https://en.wikipedia.org/wiki/Cache_stampede), occurs when a cache expires during very high load. Many users regenerate the just expired cache value and query the database. The more users hit the database, the slower and less responsive it gets. 

One way to prevent this is, when only the first user regenerates a cache value while all other users get a stale value until the cache is regenerated by the first user. Serving stale data is a better tradeoff than a database being overloaded ;-)

Many implementations of this approach use a second cache key (stale key) to keep track of this. A downside of that the additional cache key increases writes to the cache backend.
Luckily the additional cache value can be used in combination with the Russian doll cache.

## Sources: Russian Doll Cache
* [How key-based cache expiration works, 2012](https://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works)
* [How Basecamp Next got to be so damn fast without using much client-side UI, 2012](https://signalvnoise.com/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui)
* [Matryoshka, PHP library, 2016](https://github.com/laracasts/matryoshka)

## Sources: Dog pile effect
* [Avoiding the Memcache ‘dog pile’ effect](https://www.leaseweb.com/labs/2013/03/avoiding-the-memcache-dog-pile-effect/)
* [Dog-pile Effect and How to Avoid it with Ruby on Rails memcache-client Patch](https://kovyrin.net/2008/03/10/dog-pile-effect-and-how-to-avoid-it-with-ruby-on-rails-memcache-client-patch/)
* [Preventing the dogpile effect, 2014](http://www.sobstel.org/blog/preventing-dogpile-effect/)

--- 

For example: Assuming there are groups and items. A group can have many items. A template should how information about a group and all it's items.

In the [Twig](http://twig.sensiolabs.org) template language with the [Twig Cache Extension](https://github.com/twigphp/twig-cache-extension) the template could look like this:

```twig
{% cache 'group', key: group.cacheKey %}
    {# ... #}
    
    {% for item in group.items %}
        {% cache 'group_items', key: item.cacheKey %}
            {# ... #}
        {% endcache %}
    {% endfor %}
{% endcache %} 
```

A template is composed of smaller cached parts (fragments). 
Each fragment is cached individually. The `cacheKey` is based on an ID and last updated timestamp of a group or item.

```php
class Group {
    // ...
    public function getCacheKey() {
	    return $this->id . ' ' . $this->updatedAt;
    }
}
```

A prerequisite of this approach is, that there are *last updated timestamps* propagated in the hierarchy. When an item changes, the last updated timestamp of the parent group should be updated as well. If the group updates, the last updated timestamps of all of it's items should be updated.

--- 

In my case a Symfony3 application using the [Twig Cache Extension](https://github.com/twigphp/twig-cache-extension)

```
{% cache 'v1` %}
    {% for item in items %}
        {% cache 'v1' item %}
            {# ... #}
        {% endcache %}
    {% endfor %}
{% endcache %}
```

In `events.twig.html`:
```html
{% cache event.cacheKey   %}
	<h1>event.title</h1>
	
  {% cache 'event_comments' ~ event.cacheKey   %}
			{{ render(controller('event_comments', event.comments)) }}
	{% endcache %}
	
{% endcache %}
```

In `event_comments.twig.html`:
```html
<ul class="comments">
    {% foreach (comment in event.comments) %}
				{{ render(controller('comment', comment)) }}
    {% endforeach %}
</ul>
```
