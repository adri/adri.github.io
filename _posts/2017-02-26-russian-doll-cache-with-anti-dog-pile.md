---
layout: post
title: Improving Caching of Nested Fragment for Traffic Spikes
summary: 
categories: cache, invalidation
image: 
published: false
---

Last week I learned about two caching techniques and how to combined them to get a more effective caching strategy.

First I wanted to solve the **"dogpile" effect** which , then I learned about the **"Russian doll" approach** for caching nested template fragments. 



## Dog Pile Effect
The **"dogpile" effect**, also [cache stampede](https://en.wikipedia.org/wiki/Cache_stampede), occurs when a cache expires during a traffic spike. Many users regenerate the just expired cache value and query the database. The more users hit the database, the slower and less responsive it gets. 

One way to prevent this is, that only the first user regenerates a cache value while all other users receive a stale value until the cache is regenerated by the first user. Serving stale data is a better tradeoff than a database being overloaded ;-)

## Russian Doll Cache
Then I learned about the **"Russian doll" approach** for caching nested template fragments which works well for hierarchical data. A prerequisite of this approach is, that there are *last updated timestamps* propagated in the hierarchy.

A template is then composed of smaller cached parts (fragments). The cache keys used for the fragments rely on last updated timestamps of the data they show. 


are cached individually. 

This is effective when composing  Using `updated_at` timestamps for cache keys of the fragments allows for individual cache updates and minimal re-rendering. 
 

## Sources: Russian Doll Cache
* [How key-based cache expiration works, 2012](https://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works)
* [How Basecamp Next got to be so damn fast without using much client-side UI, 2012](https://signalvnoise.com/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui)
* [Matryoshka, PHP library, 2016](https://github.com/laracasts/matryoshka)

## Sources: Dog pile effect
* [Avoiding the Memcache ‘dog pile’ effect](https://www.leaseweb.com/labs/2013/03/avoiding-the-memcache-dog-pile-effect/)
* [Dog-pile Effect and How to Avoid it with Ruby on Rails memcache-client Patch](https://kovyrin.net/2008/03/10/dog-pile-effect-and-how-to-avoid-it-with-ruby-on-rails-memcache-client-patch/)
* [Preventing the dogpile effect, 2014](http://www.sobstel.org/blog/preventing-dogpile-effect/)



In my case a Symfony3 application using the [Twig Cache Extension](https://github.com/twigphp/twig-cache-extension)

```
{% cache 'v1` %}
    {% for item in items %}
        {% cache 'v1' item %}
            {# ... #}
        {% endcache %}
    {% endfor %}
{% endcache %}
```




In `events.twig.html`:
```html
{% cache event.cacheKey   %}
	<h1>event.title</h1>
	
  {% cache 'event_comments' ~ event.cacheKey   %}
			{{ render(controller('event_comments', event.comments)) }}
	{% endcache %}
	
{% endcache %}
```

In `event_comments.twig.html`:
```html
<ul class="comments">
    {% foreach (comment in event.comments) %}
				{{ render(controller('comment', comment)) }}
    {% endforeach %}
</ul>
```


What is the dogpile effect?

Twig 
