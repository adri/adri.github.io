---
layout: post
title: My Elixir Side-Project: Exploration Phase
summary: 
categories: elixir
image: 
published: false
---

To really learn something, I believe 


After getting [an overview of the Elixir language](/post/why-elixir-has-great-potential) and diving into great books like [Elixir in Action](https://www.manning.com/books/elixir-in-action) it was finally time for me to start on a side-project. 

## Finding a problem to solve
Like every developer who wants to use a new technology I needed a problem to solve. A nail for the new hammer. Luckily 

What is elixir particularly good for?



## Code
- phoenix 1.3
- phoenix presence
- phoenix channels
- GitHub authentication
- jira api
- con_cache for caching

## Deployment
- heroku with [Github integration](https://devcenter.heroku.com/articles/github-integration)
- pryn

## What's next?

* Testing
* Cleanup 
	* credo
	* Think more about code structure and runtime concerns based on the article [To spawn, or not to spawn?](http://theerlangelist.com/article/spawn_or_not)
* GraphQL with Absinthe with subscriptions
* CI setup 



Last week I learned about two caching techniques and how to combine them to get a more effective caching strategy.

First I learned about the **Russian doll approach** for caching nested template partials, then I wanted to solve the **dog-pile effect** which can happen during a traffic spike.
 
## Russian Doll Cache
For caching nested template partials the **Russian doll approach** works well with timestamp-based cache keys. How this works is nicely explained in the article [How key-based cache expiration works](https://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works). Using last updated timestamps for cache keys allows for individual cache updates and minimal re-rendering. The cache value only needs to be regenerated when the timestamp changes.

This great unless the cache key changes during a traffic spike. The high load can lead to the "dog-pile" effect.

## Dog Pile Effect
The **dog-pile effect**, also [cache stampede](https://en.wikipedia.org/wiki/Cache_stampede), occurs when a cache expires during very high load. Many users regenerate the just expired cache value and query the database. The more users hit the database, the slower and less responsive it gets. 

One way to prevent this is, when only the first user regenerates a cache value while all other users get a stale value. The cache gets locked until the cache is regenerated by the first user. Serving a stale value is a better tradeoff than a database being overloaded ;-) 

Many implementations of this approach use a second cache key (stale key) to keep track of the lock. The additional cache key increases writes to the cache backend. Luckily the additional cache value can be used in combination with the Russian doll cache.

## Combining the two



## Sources: Russian Doll Cache
* [How key-based cache expiration works, 2012](https://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works)
* [How Basecamp Next got to be so damn fast without using much client-side UI, 2012](https://signalvnoise.com/posts/3112-how-basecamp-next-got-to-be-so-damn-fast-without-using-much-client-side-ui)
* [Matryoshka, PHP library, 2016](https://github.com/laracasts/matryoshka)

## Sources: Dog pile effect
* [Avoiding the Memcache ‘dog pile’ effect](https://www.leaseweb.com/labs/2013/03/avoiding-the-memcache-dog-pile-effect/)
* [Dog-pile Effect and How to Avoid it with Ruby on Rails memcache-client Patch](https://kovyrin.net/2008/03/10/dog-pile-effect-and-how-to-avoid-it-with-ruby-on-rails-memcache-client-patch/)
* [Preventing the dogpile effect, 2014](http://www.sobstel.org/blog/preventing-dogpile-effect/)

--- 

For example: Assuming there are groups and items. A group can have many items. A template should how information about a group and all it's items.

In the [Twig](http://twig.sensiolabs.org) template language with the [Twig Cache Extension](https://github.com/twigphp/twig-cache-extension) the template could look like this:

```twig
{% cache 'group', key: group.cacheKey %}
    {# ... #}
    
    {% for item in group.items %}
        {% cache 'group_items', key: item.cacheKey %}
            {# ... #}
        {% endcache %}
    {% endfor %}
{% endcache %} 
```

A template is composed of smaller cached parts (fragments). 
Each fragment is cached individually. The `cacheKey` is based on an ID and last updated timestamp of a group or item.

```php
class Group {
    // ...
    public function getCacheKey() {
	    return $this->id . ' ' . $this->updatedAt;
    }
}
```

A prerequisite of this approach is, that there are *last updated timestamps* propagated in the hierarchy. When an item changes, the last updated timestamp of the parent group should be updated as well. If the group updates, the last updated timestamps of all of it's items should be updated.

--- 

In my case a Symfony3 application using the [Twig Cache Extension](https://github.com/twigphp/twig-cache-extension)

```
{% cache 'v1` %}
    {% for item in items %}
        {% cache 'v1' item %}
            {# ... #}
        {% endcache %}
    {% endfor %}
{% endcache %}
```

In `events.twig.html`:
```html
{% cache event.cacheKey   %}
	<h1>event.title</h1>
	
  {% cache 'event_comments' ~ event.cacheKey   %}
			{{ render(controller('event_comments', event.comments)) }}
	{% endcache %}
	
{% endcache %}
```

In `event_comments.twig.html`:
```html
<ul class="comments">
    {% foreach (comment in event.comments) %}
				{{ render(controller('comment', comment)) }}
    {% endforeach %}
</ul>
```
