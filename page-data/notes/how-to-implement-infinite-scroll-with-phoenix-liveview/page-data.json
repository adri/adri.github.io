{"componentChunkName":"component---plugins-gatsby-theme-brain-src-templates-brain-js","path":"/notes/how-to-implement-infinite-scroll-with-phoenix-liveview","result":{"data":{"brainNote":{"slug":"how-to-implement-infinite-scroll-with-phoenix-liveview","title":"How to implement infinite scroll with Phoenix LiveView","inboundReferenceNotes":[],"inboundReferences":[],"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Subscribing to scroll events can cause performance and concurrency issues because when scrolling, hundreds of events can be triggered.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"A performant way to react to scroll events is the Interaction Observer.\"), mdx(\"p\", null, \"The Interaction Observer observes if an element is visible within another element. In this case a element is added to the end of the list. When it becomes visible inside of the window element, a \\\"load more\\\" event is triggered.\"), mdx(\"h3\", null, \"Phoenix LiveView\"), mdx(\"p\", null, \"In the template, add  an HTML element \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"after\"), \" the list. The position of the element will be observed within the window.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elixir\"\n  }), \"defmodule DemoWeb.UserLive.IndexAutoScroll do\\n  use Phoenix.LiveView\\n\\n  alias DemoWeb.UserLive.Row\\n\\n  def render(assigns) do\\n    ~L\\\"\\\"\\\"\\n    <table>\\n      <tbody id=\\\"users\\\" phx-update=\\\"append\\\">\\n        <%= for user <- @users do %>\\n          <%= live_component @socket, Row, id: \\\"user-#{user.id}\\\", user: user %>\\n        <% end %>\\n      </tbody>\\n    </table>\\n    <div phx-hook=\\\"InfiniteScroll\\\" data-page=\\\"<%= @page %>\\\"></div>\\n    \\\"\\\"\\\"\\n  end\\n\\n  def mount(_params, _session, socket) do\\n    {:ok,\\n     socket\\n     |> assign(page: 1, per_page: 10)\\n     |> fetch(), temporary_assigns: [users: []]}\\n  end\\n\\n  defp fetch(%{assigns: %{page: page, per_page: per}} = socket) do\\n    assign(socket, users: Demo.Accounts.list_users(page, per))\\n  end\\n\\n  def handle_event(\\\"load-more\\\", _, %{assigns: assigns} = socket) do\\n    {:noreply, socket |> assign(page: assigns.page + 1) |> fetch()}\\n  end\\nend\\n\")), mdx(\"h3\", null, \"Javascript  Hook\"), mdx(\"p\", null, \"This hook initializes an Interaction Observer and triggers a \\\"load-more\\\" event once the added element becomes visible within the window.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export const InfiniteScroll = {\\n  page() {\\n    return this.el.dataset.page;\\n  },\\n  loadMore(entries) {\\n    const target = entries[0];\\n\\n    if (target.isIntersecting && this.pending == this.page()) {\\n      this.pending = this.page() + 1;\\n      this.pushEvent(\\\"load-more\\\", {});\\n    }\\n  },\\n  mounted() {\\n    this.pending = this.page();\\n    this.observer = new IntersectionObserver(\\n      (entries) => this.loadMore(entries),\\n      {\\n        root: null, // window by default\\n        rootMargin: \\\"0px\\\",\\n        threshold: 1.0,\\n      }\\n    );\\n    this.observer.observe(this.el);\\n  },\\n  beforeDestroy() {\\n    this.observer.unobserve(this.el);\\n  },\\n  updated() {\\n    this.pending = this.page();\\n  },\\n};\\n\")), mdx(\"p\", null, \"Use the hook like any other hook in LiveView.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import {InfiniteScroll} from \\\"./infinite_scroll\\\"\\n\\n// ...\\n\\nlet liveSocket = new LiveSocket(\\\"/live\\\", Socket, {hooks: {InfiniteScroll}, params: {_csrf_token: csrfToken}})\\n\")), mdx(\"h3\", null, \"Sources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Elixir Forum \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://elixirforum.com/t/how-can-i-implement-an-infinite-scroll-in-liveview/30457/2\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"How can I implement an infinite scroll in liveview?\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mozilla developer \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Interaction Observer API\"))), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../../../notes/phoenixliveview\"\n  }), \"#PhoenixLiveView\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../../../notes/published\"\n  }), \"#published\"), \" \"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Subscribing to scroll events can cause performance and concurrency issues because when scrolling, hundreds of events can be triggered. Aâ€¦","timeToRead":1}}},"pageContext":{"slug":"how-to-implement-infinite-scroll-with-phoenix-liveview"}},"staticQueryHashes":["318001574","3787687951"]}