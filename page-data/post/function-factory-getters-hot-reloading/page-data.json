{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/post/function-factory-getters-hot-reloading","result":{"data":{"post":{"__typename":"MdxPost","slug":"/post/function-factory-getters-hot-reloading","title":"NodeJS: Factory Function Pattern, Dependency Registry and Hot Reloading","date":"2016-01-20","tags":null,"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"NodeJS: Factory Function Pattern, Dependency Registry and Hot Reloading\",\n  \"slug\": \"/post/function-factory-getters-hot-reloading\",\n  \"summary\": \"This article shows how to combine Factory Functions with a rapid feedback loop using hot reloading.\",\n  \"date\": \"2016-01-20T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Factory Functions Pattern are a great way to structure applications in NodeJS. This \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://medium.com/@pyrolistical/factory-functions-pattern-in-depth-356d14801c91#.3193wonrd\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"In-Depth article\"), \" describes how they are used. In short, the advantages of this pattern are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All external dependencies of a module are stated explicitly\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"External dependencies can be replaced without changing the module\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unittesting works by passing in mocked/testing dependencies\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"No global references\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Inversion_of_control\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Inversion of control\"))), mdx(\"p\", null, \"This post shows how to:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Code using the Factory Function pattern\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Wire up dependencies in one place\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Hot reload a server for fast iteration\")), mdx(\"p\", null, \"Example screencast how to use hot reloading in PHPStorm or Webstorm:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://cloud.githubusercontent.com/assets/133832/12606723/df0e20d0-c4cf-11e5-9905-97150c0738d8.gif\",\n    \"alt\": \"run-with-hot-reload\"\n  }))), mdx(\"h2\", null, \"Wiring up dependencies\"), mdx(\"p\", null, \"More complex NodeJS applications can gain maintainability and testability from such a structure.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"Dependencies of the app can be wired up in one place.\"), mdx(\"p\", null, \"An example which runs with NodeJS > 4.x looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// In file ./index.js\\n\\n// Wire up dependencies\\nconst leveldb = require(\\\"leveldb\\\");\\nconst express = require(\\\"express\\\");\\nconst User = require(\\\"./model/User\\\")();\\nconst userRepository = require(\\\"./repository/UserRepository\\\")(leveldb);\\nconst userService = require(\\\"./service/UserService\\\")(userRepository, User);\\nconst userController = require(\\\"./controller/UserController\\\")(userService);\\n\\nconst app = express();\\n// Attach routes\\nuserController.routes(app);\\n\\napp.listen(3000, () => console.log(\\\"Listening on http://localhost:3000\\\"));\\n\")), mdx(\"h2\", null, \"Example UserService implementation\"), mdx(\"p\", null, \"To illustrate how injected dependencies can be used, an example implementation of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserService\"), \" could be something like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// In file ./src/service/UserService.js\\n\\n// userRepository and User are external dependencies.\\nmodule.exports = (userRepository, User) => {\\n  return {\\n    /**\\n     * Login a user with the given login provider and user profile.\\n     *\\n     * @param  {string} provider Login provider which was used (google, facebook, ...)\\n     * @param  {Object} profile User profile from that provider.\\n     * @return {User} Logged in user.\\n     */\\n    loginWithProvider: (provider, profile) => {\\n      return (\\n        userRepository\\n          .findByProvider(provider, profile)\\n          // If not found, this is a new user.\\n          .then((user) => user || User.fromProvider(provider, profile))\\n          .then((user) => user.updateLastLogin())\\n          .then((user) => userRepository.store(user))\\n      );\\n    },\\n  };\\n};\\n\")), mdx(\"p\", null, \"There are two injected dependencies, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"userRepository\"), \" and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \" model. These dependencies can be accessed in the returned object with currently one function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"loginWithProvider\"), \". Other function could be added here, they would share the same dependencies.\"), mdx(\"h2\", null, \"Example usage of the \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"UserService\")), mdx(\"p\", null, \"A wired up instance of the example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserService\"), \" can then be used in other places of the app, like for example\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"controllers. The same principles applies there:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// In file ./src/controllers/UserController.js\\n\\nmodule.exports = (userService) => {\\n  function login(req, res, next) {\\n    return userService\\n      .loginWithProvider(req.query.provider, req.query.profile)\\n      .then((user) => res.json(user))\\n      .catch(next);\\n  }\\n\\n  return {\\n    routes: (app) => {\\n      app.get(\\\"/login\\\", login);\\n    },\\n  };\\n};\\n\")), mdx(\"p\", null, \"Now all dependencies are injected and wired up at one place. Nice!\"), mdx(\"h2\", null, \"Refactor to support Hot Reloading\"), mdx(\"p\", null, \"When apps grow, the startup cost increases due to parsing javascript files\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"and making connections to databases and servies. Hot reloading NodeJS apps \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"avoids the startup costs\"), \" and\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"lets you \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"iterate quicker\"), \". To make this possible the previous structure needs a little refactoring.\"), mdx(\"p\", null, \"We have to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"move out the dependencies\"), \" into another file which can be reloaded on file changes.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"The dependencies then need to be exported to be used:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// In ./src/dependencies.js\\n\\n// Static dependencies, changing these requires a restart\\n// in hot reloading mode.\\nconst level = require(\\\"level\\\");\\nconst leveldb = require(\\\"level-promisify\\\")(level);\\nconst express = require(\\\"express\\\");\\n\\nconst app = express();\\n\\nconst deps = {\\n  // Dynamic dependencies which will be hot reloaded.\\n  // Use ES6 getters to require when needed.\\n\\n  app,\\n\\n  get routes() {\\n    deps.userController.routes(deps.app);\\n    return app;\\n  },\\n\\n  get User() {\\n    return require(\\\"./model/User\\\")();\\n  },\\n  get userRepository() {\\n    return require(\\\"./repository/UserRepository\\\")(leveldb);\\n  },\\n  get userService() {\\n    return require(\\\"./service/UserService\\\")(deps.userRepository, deps.User);\\n  },\\n  get userController() {\\n    return require(\\\"./controller/UserController\\\")(deps.userService);\\n  },\\n};\\n\\nmodule.exports = deps;\\n\")), mdx(\"p\", null, \"This is how the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"./index.js\"), \" looks like after the refactoring:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// In file ./index.js\\n\\n// Start with hot reloading: node index hotreload\\nconst isHot = process.argv[2] === \\\"hotreload\\\";\\nconst app = isHot ? require(\\\"./hotreload\\\") : require(\\\"./src/server\\\");\\n\\napp.listen(3000, () => console.log(\\\"Listening on http://localhost:3000\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// In file ./src/server.js\\n\\nconst dependencies = require(\\\"./dependencies\\\");\\nconst app = dependencies.app;\\nconst routes = dependencies.routes;\\n\\napp.use(routes);\\n\\nmodule.exports = app;\\n\")), mdx(\"p\", null, \"For hot reloading, create a new file:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// In file ./src/hotreload.js\\nconst chokidar = require(\\\"chokidar\\\");\\nconst dependencies = require(\\\"./src/dependencies\\\");\\nconst app = dependencies.app;\\n\\n// Include server routes as a middleware\\napp.use((req, res, next) => {\\n  // Require all dependencies.\\n  dependencies.routes(req, res, next);\\n});\\n\\n// Do \\\"hot-reloading\\\" of express stuff on the server\\n// Throw away cached modules and re-require next time\\n// Ensure there's no important state in there!\\nconst watcher = chokidar.watch([\\\"./src\\\"]);\\nwatcher.on(\\\"ready\\\", () => {\\n  watcher.on(\\\"all\\\", () => {\\n    console.log(\\\"Clearing module cache from server\\\");\\n    Object.keys(require.cache).forEach((file) => {\\n      if (/src/.test(file) && file.indexOf(\\\"node_modules\\\") === -1) {\\n        delete require.cache[file];\\n      }\\n    });\\n  });\\n});\\n\\nmodule.exports = app;\\n\")), mdx(\"h2\", null, \"Complete example\"), mdx(\"p\", null, \"A complete example can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/adri/node-hotreload-example\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"on github\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Factory Functions Pattern are a great way to structure applications in NodeJS. This  In-Depth article  describes how they are used. In short…","timeToRead":1,"banner":null}},"pageContext":{"slug":"/post/function-factory-getters-hot-reloading","formatString":"YYYY-MM-DD"}},"staticQueryHashes":["318001574","3787687951","3787687951"]}