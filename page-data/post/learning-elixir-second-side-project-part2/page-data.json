{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/post/learning-elixir-second-side-project-part2","result":{"data":{"post":{"__typename":"MdxPost","slug":"/post/learning-elixir-second-side-project-part2","title":"Elixir side-project #2: A Graphql API with Elixir (2/2)","date":"2017-10-02","tags":null,"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"Elixir side-project #2: A Graphql API with Elixir (2/2)\",\n  \"slug\": \"/post/learning-elixir-second-side-project-part2\",\n  \"summary\": \"Building a GraphQL API for my recipe planning side-project.\",\n  \"categories\": \"elixir, side-project, graphql, react, next.js\",\n  \"banner\": \"https://user-images.githubusercontent.com/133832/30913555-ede256ac-a390-11e7-8f3a-b8e70b00e702.png\",\n  \"published\": true,\n  \"date\": \"2017-10-02T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A first proof of concept for my side-project to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/post/learning-elixir-second-side-project-part1\"\n  }), \"manage and order recipes and ingredients via a supermarket API\"), \" was successful. I continued with making a GraphQL API and a web interface with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/zeit/next.js\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"next.js\"), \" + \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.apollodata.com\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Apollo\"), \".\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"760px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/4b151e849f762b7044a7d3283501abe4/2261b/elixir-with-graphql.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"39.583333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/svg+xml,%3csvg%20xmlns=\\\\'http://www.w3.org/2000/svg\\\\'%20width=\\\\'400\\\\'%20height=\\\\'158\\\\'%20viewBox=\\\\'0%200%20400%20158\\\\'%20preserveAspectRatio=\\\\'none\\\\'%3e%3cpath%20d=\\\\'M101%2041c-3%201-4%203-4%206S82%2058%2080%2057c-8-4-14%205-8%2011%202%202%202%203%202%2011s0%209-2%2011c-6%206%200%2015%208%2011%202-1%2017%207%2017%2010%200%204%204%207%207%207%204%200%207-3%207-6s15-13%2017-11%207%201%209-1c3-3%203-7%200-10-3-2-3-3-3-11s0-9%203-11c5-6-2-16-9-11-2%201-17-8-17-11%200-5-5-8-10-5M91%2056l-8%205h43l-8-5c-7-4-8-4-11-3h-5c-3-2-4-1-11%203m172%200c-3%202-7%209-8%2016-1%205-1%205-2%203s-1-2-2%203c-3%209-1%2017%205%2022%203%203%204%203%203-1%200-5%202-5%208-1%202%202%203%202%204%201l4-1c3%201%204-1%200-3-2-1-2-1-1-2l4%201c1%202%201%202%202-1%202-7%201-12-5-17l-3-4c0-2-1-2-2-2v-1h-1v-1l-1-1-1-4-1-7-1-2-2%202M82%2066c-2%203%2018%2037%2022%2038%203%200%2024-35%2022-38s-42-3-44%200m108%206c0%204-1%205-5%205-3%200-4%200-4%202s1%202%205%202h4v5c0%206%203%206%204-1%200-4%200-4%204-4%203%200%204%200%204-2s-1-2-4-2c-4%200-4%200-4-4-1-6-4-7-4-1M78%2079c0%209%200%209%202%2011%202%201%203%203%203%205s2%203%208%207l8%204-11-18-10-18v9m41%209l-9%2018c8-4%2015-9%2015-11l3-5c2-2%202-3%202-11v-8l-11%2017m181-11c-3%201-4%204-4%208%200%208%203%2011%2011%2010%205-1%204-4-1-3-4%200-7-1-7-4l6-1c6%200%207-1%205-6-2-4-5-6-10-4m33%200l2%204c3%204%203%205%200%209s-4%205-2%205l4-3%202-3%203%203c5%206%207%204%202-2-2-5-3-4%202-11v-2c-1-1-3%201-5%204-1%201-1%201-4-2-1-1-3-3-4-2\\\\'%20fill=\\\\'%23d3d3d3\\\\'%20fill-rule=\\\\'evenodd\\\\'/%3e%3c/svg%3e')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"picture\", {\n    parentName: \"a\"\n  }, \"\\n        \", mdx(\"source\", _extends({\n    parentName: \"picture\"\n  }, {\n    \"srcSet\": [\"/static/4b151e849f762b7044a7d3283501abe4/cbea2/elixir-with-graphql.webp 240w\", \"/static/4b151e849f762b7044a7d3283501abe4/42669/elixir-with-graphql.webp 480w\", \"/static/4b151e849f762b7044a7d3283501abe4/68412/elixir-with-graphql.webp 760w\"],\n    \"sizes\": \"(max-width: 760px) 100vw, 760px\",\n    \"type\": \"image/webp\"\n  })), \"\\n        \", mdx(\"source\", _extends({\n    parentName: \"picture\"\n  }, {\n    \"srcSet\": [\"/static/4b151e849f762b7044a7d3283501abe4/5243c/elixir-with-graphql.png 240w\", \"/static/4b151e849f762b7044a7d3283501abe4/ab158/elixir-with-graphql.png 480w\", \"/static/4b151e849f762b7044a7d3283501abe4/2261b/elixir-with-graphql.png 760w\"],\n    \"sizes\": \"(max-width: 760px) 100vw, 760px\",\n    \"type\": \"image/png\"\n  })), \"\\n        \", mdx(\"img\", _extends({\n    parentName: \"picture\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"src\": \"/static/4b151e849f762b7044a7d3283501abe4/2261b/elixir-with-graphql.png\",\n    \"alt\": \"GraphQL and Elixir\",\n    \"title\": \"GraphQL and Elixir\",\n    \"loading\": \"lazy\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    }\n  })), \"\\n      \"), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"This is part 2 of a blog post series \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Elixir side-project #2\"), \".\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/post/learning-elixir-second-side-project-part1\"\n  }), \"Planning Recipes with a Supermarket API (1/2)\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A Graphql API with Elixir (2/2)\")), mdx(\"h3\", null, \"GraphQL and Elixir\"), mdx(\"p\", null, \"I assume you\\u2019ve read about GraphQL. Otherwise I recommend to read an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://graphql.org\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"introduction\"), \" or watch a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=WQLzZf34FJ8\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"talk\"), \". If you want to learn more about Elixir see my blog post \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/post/why-elixir-has-great-potential\"\n  }), \"why the Elixir language has great potential\"), \".\"), mdx(\"p\", null, \"The most used GraphQL library for Elixir is \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://absinthe-graphql.org\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Absinthe\"), \". The maintainers are very active on the\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://elixir-slackin.herokuapp.com/\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"#absinthe-graphql\"), \" Slack channel\"), \" and they are \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://pragprog.com/book/wwgraphql/craft-graphql-apis-in-elixir-with-absinthe\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"writing a book\"), \" about Absinthe.\"), mdx(\"h4\", null, \"Installation\"), mdx(\"p\", null, \"I'm using the currently latest Absinthe version which is 1.4-rc and also some helper libraries. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"absinthe_relay\"), \" needs to be updated to 1.4 which is why I use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"override: true\"), \". In the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mix.exs\"), \" file I put these dependencies:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elixir\"\n  }), \"{:absinthe, \\\"~> 1.4.0-rc\\\", override: true},\\n{:absinthe_plug, \\\"~> 1.4.0-rc\\\"},\\n{:absinthe_phoenix, \\\"~> 1.4.0-rc\\\"},\\n{:absinthe_relay, \\\"~> 1.3.0\\\"},\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"absinthe_plug\"), \" for integration with plug and adding GraphiQL, \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/absinthe-graphql/absinthe_plug#graphiql\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"setup\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"absinthe_phoenix\"), \" for playing with GraphQL subscriptions, \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/absinthe-graphql/absinthe_phoenix\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"setup\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"absinthe_relay\"), \" because I like to expose only \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://facebook.github.io/relay/docs/graphql-object-identification.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Global IDs\"), \". This enables \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://dev.apollodata.com/react/cache-updates.html#normalization\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"automatic store updates\"), \" using Apollo.\")), mdx(\"h4\", null, \"Schema Definition\"), mdx(\"p\", null, \"The Picape domain is small enough to define in two files: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/adri/picape/blob/master/lib/picape_web/graphql/schema.ex\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"schema.ex\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/adri/picape/blob/master/lib/picape_web/graphql/types.ex\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"types.ex\"), \". Here is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"query schema overview\"), \" made with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://apis.guru/graphql-voyager/\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"GraphQL Voyager\"), \" (click the image to enlarge).\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://user-images.githubusercontent.com/133832/31045265-f7c5d918-a5df-11e7-9c28-88ee5d738fa7.png\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"960px\"\n    }\n  }), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"19.166666666666664%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/svg+xml,%3csvg%20xmlns=\\\\'http://www.w3.org/2000/svg\\\\'%20width=\\\\'400\\\\'%20height=\\\\'77\\\\'%20viewBox=\\\\'0%200%20400%2077\\\\'%20preserveAspectRatio=\\\\'none\\\\'%3e%3cpath%20d=\\\\'M202%2014c1%203%202%204%203%202%200-2%2020-2%2020%200s3-2%203-4l-13-1h-13v3M13%2028c0%202%201%202%203%202h4l-3%201c-3%201-3%201%202%201%204%200%205%200%204-1-2-1%204-1%2013-1%2015%200%2016%200%2016-2s-1-2-19-2c-19%200-20%200-20%202m298%203c0%202%201%202%2013%202l13%201c1%202%203-1%203-3s-1-2-14-2c-14%200-15%200-15%202M91%2054c0%202%201%202%2010%202l9%201%203%201c2%200%202%200%201-1-2-1-2-1%200-1l2-2c-1-1-4-2-13-2-11%200-12%200-12%202\\\\'%20fill=\\\\'%23d3d3d3\\\\'%20fill-rule=\\\\'evenodd\\\\'/%3e%3c/svg%3e')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"picture\", {\n    parentName: \"span\"\n  }, \"\\n        \", mdx(\"source\", _extends({\n    parentName: \"picture\"\n  }, {\n    \"srcSet\": [\"/static/1abdedcb7ccdbf041dbb482c1710eb3b/cbea2/picape-graphql-schema.webp 240w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/42669/picape-graphql-schema.webp 480w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/10c02/picape-graphql-schema.webp 960w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/fead5/picape-graphql-schema.webp 1440w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/7e36f/picape-graphql-schema.webp 1920w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/d3b34/picape-graphql-schema.webp 2592w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"type\": \"image/webp\"\n  })), \"\\n        \", mdx(\"source\", _extends({\n    parentName: \"picture\"\n  }, {\n    \"srcSet\": [\"/static/1abdedcb7ccdbf041dbb482c1710eb3b/5243c/picape-graphql-schema.png 240w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/ab158/picape-graphql-schema.png 480w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/7d769/picape-graphql-schema.png 960w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/87339/picape-graphql-schema.png 1440w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/88b03/picape-graphql-schema.png 1920w\", \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/93a92/picape-graphql-schema.png 2592w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"type\": \"image/png\"\n  })), \"\\n        \", mdx(\"img\", _extends({\n    parentName: \"picture\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"src\": \"/static/1abdedcb7ccdbf041dbb482c1710eb3b/7d769/picape-graphql-schema.png\",\n    \"alt\": \"Picape GraphQL Schema overview\",\n    \"title\": \"Picape GraphQL Schema overview\",\n    \"loading\": \"lazy\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    }\n  })), \"\\n      \"), \"\\n    \"))), mdx(\"p\", null, \"Absinthe provides macros to make schema definitions concise. For example the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"query\"), \" macro can be used to define the root query fields. In the following example we define a field \\\"recipes\\\" using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"field\"), \" macro. That field resolves to a list of recipes using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve\"), \" macro.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elixir\"\n  }), \"query do\\n  @desc \\\"Lists all recipes.\\\"\\n  field :recipes, list_of(:recipe) do\\n    resolve &Resolver.Recipe.all/3\\n  end\\nend\\n\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/adri/picape/blob/master/lib/picape_web/graphql/schema.ex\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Source code of the whole schema\")), mdx(\"p\", null, \"The types file defines all object types using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"object\"), \" macro. In this case I used the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node\"), \" macro which defines a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://facebook.github.io/relay/graphql/objectidentification.htm#sec-Node-Interface\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Relay node interface\"), \". This just means that this object will get an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field with a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://facebook.github.io/relay/docs/graphql-object-identification.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"globally unique ID\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elixir\"\n  }), \"node object :recipe do\\n  field :title, :string\\n  field :image_url, :string\\n  field :is_planned, :boolean do\\n    resolve: batched({Resolver.Order, :recipies_planned?})\\n  end\\n  field :ingredients, list_of(:recipe_ingredient_edge) do\\n    resolve: batched({Resolver.Recipe, :ingredients_by_recipe_ids})\\n  end\\nend\\n\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/adri/picape/blob/master/lib/picape_web/graphql/types.ex\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Source code of all types\")), mdx(\"p\", null, \"Resolvers take care of mapping the GraphQL schema to actual data. I see resolvers as glue code \\u2013 the actual logic of how to fetch data should be in another layer of the application. I liked combining this with the concept of Phoenix 1.3 contexts. This way my resolvers are mostly one or two line calls to the relevant contexts.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elixir\"\n  }), \"defmodule PicapeWeb.Graphql.Resolver.Recipe do\\n  alias Picape.Recipe\\n\\n  def all(_parent, _args, _info) do\\n    {:ok, Recipe.list_recipes()}\\n  end\\nend\\n\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/adri/picape/blob/master/lib/picape_web/graphql/resolver/recipe.ex\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Source code of all recipe resolvers\")), mdx(\"h4\", null, \"Phoenix 1.3 Contexts\"), mdx(\"p\", null, \"Phoenix 1.3 introduced a concept called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hexdocs.pm/phoenix/contexts.html#thinking-about-design\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"contexts\"), \" as way to structure and design an Elixir application.\"), mdx(\"p\", null, \"A context groups related functionality. For example the context \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Recipes\"), \" can include functions like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list_recipes\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"recipes_by_ids\"), \". The function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list_recipes\"), \" lists all recipes and can be used in many places: in a GraphQL resolver, in a Phoenix controller or in a CLI command.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elixir\"\n  }), \"defmodule Picape.Recipes do\\n  def list_recipes() do\\n    Repo.all(from recipe in Recipe)\\n  end\\nend\\n\")), mdx(\"p\", null, \"In OOP languages I often use DDD concepts like repositories, services, entities and value objects. I still have to figure out how this relates to Phoenix contexts. If you know a good comparison, please let me know.\"), mdx(\"h4\", null, \"Batching\"), mdx(\"p\", null, \"I knew that at some point I had to take care of the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://secure.phabricator.com/book/phabcontrib/article/n_plus_one/\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"n + 1 problem\"), \". In Javascript and PHP I have used a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/facebook/dataloader\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"DataLoader\"), \". Absinthe offers \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://absinthe-graphql.org/guides/ecto-best-practices/\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"batching\"), \" for this. For example to fetch all ingredients for recipes the resolver for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ingredients\"), \" field looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elixir\"\n  }), \"node object :recipe do\\n  field :ingredients, list_of(:recipe_ingredient_edge) do\\n    resolve: batched({Resolver.Recipe, :ingredients_by_recipe_ids})\\n  end\\nend\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"batched\"), \" is a helper function that I've added. It takes a tuple in the form of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{Module, :function_name}\"), \" and passes it to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"batch\"), \" function from Absinthe. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"batch\"), \" function calls this tuple with a list of all recipe ids that need their ingredients. This way there will be only one database query instead of one for every recipe.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elixir\"\n  }), \"defp batched(batch_fun) do\\n  fn parent, _args, _ctx ->\\n    batch(batch_fun, parent.id, fn results ->\\n      {:ok, batch_results} = results\\n      {:ok, Map.get(batch_results, parent.id)}\\n    end)\\n  end\\nend\\n\")), mdx(\"h4\", null, \"Parallel testing\"), mdx(\"p\", null, \"I'm using the PostgreSQL database and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/elixir-ecto/ecto\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Ecto\"), \", a popular database wrapper for Elixir. Ecto has a concept called Sandbox, which enables database tests to run in parallel. This works by wrapping \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"every database connection by a test in a transaction\"), \" and rolling it back when the tests finishes. All database changes are then isolated to the test itself.\"), mdx(\"p\", null, \"Using the Ecto Sandbox for GraphQL tests turned out to be straight forward. I made an ExUnit test case \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AbsintheCase\"), \" used by all functional tests of the GraphQL API. This test case defines some helpers and includes the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/adri/picape/blob/b1afd7ef94f95c1f847929a83b129a31f4a33c2d/test/support/absinthe_case.ex#L7\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"DataCase\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"async: true\")), \" which takes care of handling database transactions per test.\"), mdx(\"p\", null, \"I also used a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/adri/picape/blob/master/test/support/factory.ex\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Factory\"), \" to make \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://blog.danielberkompas.com/elixir/2015/07/16/fixtures-for-ecto.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"fixtures for Ecto\"), \". Fixtures are local to each test. I've seen global fixtures (e.g. database seeds) used for tests like this. The problem with this is, that then many tests depend on the same global fixtures. This makes the fixtures hard to change and maintain.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-elixir\"\n  }), \"test \\\"returns a list of essentials\\\" do\\n  # Arrange: Insert fixture data into the database\\n  insert! :essential, name: \\\"Flour\\\"\\n  insert! :essential, name: \\\"Milk\\\"\\n\\n  # Act: Run GraphQL query\\n  actual = run(\\\"{\\n     essentials {\\n      name\\n    }\\n  }\\\")\\n\\n  # Assert: Verify the response\\n  assert actual === {:ok, %{data: %{\\n    \\\"essentials\\\" => [\\n      %{ \\\"name\\\" => \\\"Flour\\\" },\\n      %{ \\\"name\\\" => \\\"Milk\\\" },\\n    ]\\n  }}}\\nend\\n\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/adri/picape/blob/master/test/graphql/query_essential_test.exs\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"Source code of the full test\"), \".\"), mdx(\"p\", null, \"I'm still growing the GraphQL tests. So far, running all tests took under 0.5 seconds. I consider this very fast for functional tests.\"), mdx(\"h3\", null, \"The Future\"), mdx(\"p\", null, \"So far I really like how GraphQL works in Elixir with Absinthe. I'm very happy with the speed of the functional tests and how concise the schema and type definitions are.\"), mdx(\"p\", null, \"I'll play with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hexdocs.pm/absinthe/1.4.0-beta.1/Absinthe.Schema.html#subscription/2\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"subscriptions\"), \" and the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hexdocs.pm/absinthe/Absinthe.Middleware.Async.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }), \"async middleware\"), \" next.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"A first proof of concept for my side-project to  manage and order recipes and ingredients via a supermarket API  was successful. I continuedâ€¦","timeToRead":3,"banner":null}},"pageContext":{"slug":"/post/learning-elixir-second-side-project-part2","formatString":"YYYY-MM-DD"}},"staticQueryHashes":["318001574","3787687951"]}